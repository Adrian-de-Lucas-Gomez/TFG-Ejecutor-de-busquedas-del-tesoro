{"ast":null,"code":"var _jsxFileName = \"C:\\\\Universidad\\\\4Universidad\\\\TFG\\\\TFG-Ejecutor-de-busquedas-del-tesoro\\\\ReactDesdeEjemplo\\\\src\\\\components\\\\formOne\\\\steps\\\\Qr.tsx\",\n    _s = $RefreshSig$();\n\nimport QRCode from \"qrcode.react\";\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst QR = props => {\n  _s();\n\n  //Referencia en el DOM al div que contiene el QR que renderizamos\n  const qrRef = useRef(null); //Donde guardamos el texto a codificar en QR\n\n  const [text, setText] = useState(\"\");\n  const [sobreEscribir, setSobreEscribir] = useState(false);\n  useEffect(() => {\n    //En caso de que haya que sobreescribir algo, me guardo que estamos sobreescribiendo y cargo \n    //los datos que ya había de esta fase      \n    if (props.getState('SobreEscribir', false)) {\n      //Indico que ya no es necesario sobreescribir nada, porque ya nos encargamos\n      setSobreEscribir(true);\n      props.setState('SobreEscribir', false, false); //Me quedo con lo que haya que sobreescribir\n\n      let estadoACargar = props.getState('DatosASobreEscribir', {\n        pregunta: \"hola\",\n        answers: [{\n          respuesta: \"\",\n          verdad: false\n        }]\n      });\n      let new_state = props.getState('DATA', [{}]);\n      estadoACargar = new_state[props.getState('FaseConfigurable', 1)]; //Me guardo tando la pregunta como las respuestas que había configuradas\n\n      setText(estadoACargar.QRText);\n    } //Este cógigo se ejecuta EXCLUSIVAMENTE cuando se va a desmontar el componente\n\n\n    return () => {};\n  }, []); //Metodo que se encarga de convertir el qr a formato png y descargarlo\n\n  const downloadQRCode = evt => {\n    //No refrescamos la pagina\n    evt.preventDefault(); //@ts-ignore (Esto es pa que no salte un error de typescript, sin esto no compila (porque asimila que es null))\n    //Cogemos el primer elemento canvas que cuelga del div al que esta asociado la referencia\n    // (qrcode.react esta representado como un <canvas></canvas>, si estuviese representado\n    //con otra etiqueta habria que poner esa)\n\n    let canvas = qrRef.current.querySelector(\"canvas\"); //devuelve un data URI el cual contiene una representación de una imagen en png\n\n    let image = canvas.toDataURL(\"image/png\"); //Creamos un componente <a> html al que vamos a asignar la informacion\n    //del QR qur vamos a descargar\n\n    let anchor = document.createElement(\"a\"); //le asignamos como referencia el qr ya convertido en imagen\n\n    anchor.href = image; //Le ponemos el nombre con el que la vamos a descargar\n\n    anchor.download = text + `.png`; //Metemos el componente <a> en el cuerpo de nuestro html de react\n\n    document.body.appendChild(anchor); //Clicamos sobre el para descargarlo\n\n    anchor.click(); //Quitamos el componente <a> puesto que ya ha cumplido su funcion\n\n    document.body.removeChild(anchor);\n  }; //Metodo utilizado para guardar los datos que actuales del\n  //QR en el registro de fases actual de la aventura\n\n\n  const guardaFase = e => {\n    //Para que no se refresque la pagina en el onSubmit\n    e.preventDefault(); //Miro a ver si hay algo que pueda guardar\n\n    if (text !== \"\") {\n      console.log(\"Llamada a guardar fase\"); //ME hago con el estado actual del array de info de la aventura\n\n      let new_state = props.getState('DATA', [{}]); //Preparo los datos que voy a añadir\n\n      let myData = {\n        tipo: \"QRStage\",\n        QRText: text\n      };\n      console.log(new_state); //Los añado a una copia del estado y establezco esta copia como el estadoa actual de las fases            \n\n      if (sobreEscribir === true) {\n        //De esta forma se puede meter el estado en unaposicion concreta en lugar de hacerlo en el final siempre\n        let position = props.getState('FaseConfigurable', 1);\n        new_state.splice(position, 1, myData);\n      } //Si no hay que sobreescribir nada simplemente pusheamos al final de los datos\n      else {\n        //Lo almaceno en la lista de fases que tengo disponibles\n        let position = props.getState('WhereToPush', 1);\n        new_state.splice(position, 0, myData);\n      }\n\n      props.setState('DATA', new_state, [{}]); //Importante aumentar el indice de donde estamos metiendo nuevos elementos a la aventura para que no \n      //se metan todos en la posicion X y que luego estén TODOS EN ORDEN INVERSO\n\n      props.setState('WhereToPush', props.getState('WhereToPush', 1) + 1, 1);\n    } else {\n      console.log(\"Rellena bien\");\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      children: \"A\\xF1ada aqui el link al que reedirige el  QR:\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      onSubmit: e => e.preventDefault(),\n      children: /*#__PURE__*/_jsxDEV(\"input\", {\n        className: \"form-control\",\n        type: \"text\",\n        required: true,\n        value: text,\n        onChange: e => setText(e.target.value)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: qrRef,\n      children: /*#__PURE__*/_jsxDEV(QRCode, {\n        value: text,\n        size: 400,\n        fgColor: \"black\",\n        bgColor: \"white\",\n        level: \"H\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 117,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      onSubmit: downloadQRCode,\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"btn btn-outline-primary mt-2\",\n        type: \"submit\",\n        children: \"Descargar QR\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 13\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      onSubmit: guardaFase,\n      children: /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"btn btn-outline-primary mt-2\",\n        type: \"submit\",\n        children: \"Guardar Fase\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 123,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 111,\n    columnNumber: 5\n  }, this);\n};\n\n_s(QR, \"W8R1z+DFc+F6ViOx3fpO/Scvy80=\");\n\n_c = QR;\nexport default QR;\n\nvar _c;\n\n$RefreshReg$(_c, \"QR\");","map":{"version":3,"sources":["C:/Universidad/4Universidad/TFG/TFG-Ejecutor-de-busquedas-del-tesoro/ReactDesdeEjemplo/src/components/formOne/steps/Qr.tsx"],"names":["QRCode","React","useState","useRef","useEffect","QR","props","qrRef","text","setText","sobreEscribir","setSobreEscribir","getState","setState","estadoACargar","pregunta","answers","respuesta","verdad","new_state","QRText","downloadQRCode","evt","preventDefault","canvas","current","querySelector","image","toDataURL","anchor","document","createElement","href","download","body","appendChild","click","removeChild","guardaFase","e","console","log","myData","tipo","position","splice","target","value"],"mappings":"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","sourcesContent":["import QRCode from \"qrcode.react\";\r\nimport React, {useState, useRef, useEffect, forwardRef, useImperativeHandle} from \"react\"\r\nimport { StepComponentProps } from '../../Steps';\r\nimport { queries } from \"@testing-library/react\";\r\n\r\n\r\nconst QR = (props: StepComponentProps): JSX.Element => {\r\n  \r\n    //Referencia en el DOM al div que contiene el QR que renderizamos\r\n    const qrRef = useRef(null);\r\n    //Donde guardamos el texto a codificar en QR\r\n    const [text, setText] = useState<string>(\"\");\r\n   type FormElement = React.FormEvent<HTMLFormElement>;\r\n   const [sobreEscribir, setSobreEscribir] = useState<boolean>(false);\r\n\r\n\r\n   useEffect(() => {\r\n\r\n    //En caso de que haya que sobreescribir algo, me guardo que estamos sobreescribiendo y cargo \r\n    //los datos que ya había de esta fase      \r\n    if(props.getState<boolean>('SobreEscribir', false)){\r\n\r\n        //Indico que ya no es necesario sobreescribir nada, porque ya nos encargamos\r\n        setSobreEscribir(true);\r\n        props.setState('SobreEscribir', false, false);\r\n\r\n        //Me quedo con lo que haya que sobreescribir\r\n        let estadoACargar = props.getState<any>('DatosASobreEscribir', {pregunta:\"hola\", answers:[{respuesta:\"\", verdad:false}]} ); \r\n        let new_state = props.getState<any>('DATA', [{}]); \r\n        estadoACargar= new_state[props.getState<number>('FaseConfigurable',1)];\r\n        \r\n        //Me guardo tando la pregunta como las respuestas que había configuradas\r\n        setText(estadoACargar.QRText);\r\n    }\r\n\r\n    //Este cógigo se ejecuta EXCLUSIVAMENTE cuando se va a desmontar el componente\r\n    return () => {}\r\n  }, []);\r\n\r\n\r\n\r\n    //Metodo que se encarga de convertir el qr a formato png y descargarlo\r\n    const downloadQRCode = (evt: React.FormEvent) => {\r\n        //No refrescamos la pagina\r\n        evt.preventDefault();\r\n        //@ts-ignore (Esto es pa que no salte un error de typescript, sin esto no compila (porque asimila que es null))\r\n        //Cogemos el primer elemento canvas que cuelga del div al que esta asociado la referencia\r\n        // (qrcode.react esta representado como un <canvas></canvas>, si estuviese representado\r\n        //con otra etiqueta habria que poner esa)\r\n        let canvas = qrRef.current.querySelector(\"canvas\");\r\n        \r\n        //devuelve un data URI el cual contiene una representación de una imagen en png\r\n        let image:string = canvas.toDataURL(\"image/png\");\r\n        \r\n        //Creamos un componente <a> html al que vamos a asignar la informacion\r\n        //del QR qur vamos a descargar\r\n        let anchor:HTMLAnchorElement = document.createElement(\"a\");\r\n        //le asignamos como referencia el qr ya convertido en imagen\r\n        anchor.href = image;\r\n        //Le ponemos el nombre con el que la vamos a descargar\r\n        anchor.download = text +`.png`;\r\n        //Metemos el componente <a> en el cuerpo de nuestro html de react\r\n        document.body.appendChild(anchor);\r\n        //Clicamos sobre el para descargarlo\r\n        anchor.click();\r\n        //Quitamos el componente <a> puesto que ya ha cumplido su funcion\r\n        document.body.removeChild(anchor);\r\n      };\r\n\r\n\r\n    //Metodo utilizado para guardar los datos que actuales del\r\n    //QR en el registro de fases actual de la aventura\r\n    const guardaFase = (e:FormElement) => {\r\n        //Para que no se refresque la pagina en el onSubmit\r\n        e.preventDefault();\r\n\r\n        //Miro a ver si hay algo que pueda guardar\r\n        if (text !== \"\"){\r\n            console.log(\"Llamada a guardar fase\")\r\n            //ME hago con el estado actual del array de info de la aventura\r\n            let new_state = props.getState<[{}]>('DATA', [{}]); \r\n            //Preparo los datos que voy a añadir\r\n            let myData = {tipo:\"QRStage\" ,QRText: text};\r\n            console.log(new_state);\r\n\r\n            //Los añado a una copia del estado y establezco esta copia como el estadoa actual de las fases            \r\n            if(sobreEscribir === true){\r\n                //De esta forma se puede meter el estado en unaposicion concreta en lugar de hacerlo en el final siempre\r\n                let position = props.getState<number>('FaseConfigurable',1);\r\n                new_state.splice(position,1,myData);\r\n            }\r\n            //Si no hay que sobreescribir nada simplemente pusheamos al final de los datos\r\n            else {\r\n                //Lo almaceno en la lista de fases que tengo disponibles\r\n                let position = props.getState<number>('WhereToPush',1);\r\n                new_state.splice(position, 0, myData);\r\n            }\r\n            \r\n            props.setState('DATA',new_state,[{}]);\r\n            //Importante aumentar el indice de donde estamos metiendo nuevos elementos a la aventura para que no \r\n            //se metan todos en la posicion X y que luego estén TODOS EN ORDEN INVERSO\r\n            props.setState<number>('WhereToPush',props.getState<number>('WhereToPush',1)+1,1);\r\n        }\r\n        else{\r\n            console.log(\"Rellena bien\")\r\n        }\r\n    }\r\n\r\n \r\n    return (\r\n    <div >\r\n        <h3>Añada aqui el link al que reedirige el  QR:</h3>\r\n        <form onSubmit={e => e.preventDefault()}>\r\n            <input className=\"form-control\" type=\"text\" required value={text} onChange ={ e =>setText(e.target.value)}></input>\r\n        </form>\r\n        <div ref={qrRef}>\r\n            <QRCode value={text} size={400} fgColor=\"black\" bgColor=\"white\" level=\"H\"  />\r\n        </div>\r\n        <form onSubmit= {downloadQRCode}>\r\n            <button className=\"btn btn-outline-primary mt-2\" type=\"submit\">Descargar QR</button>\r\n        </form>\r\n        <form onSubmit= {guardaFase}>\r\n                <button className=\"btn btn-outline-primary mt-2\" type=\"submit\">Guardar Fase</button>\r\n        </form>\r\n    </div>\r\n    )\r\n};\r\nexport default QR;"]},"metadata":{},"sourceType":"module"}